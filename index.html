<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trouve la bonne case</title>
  <style>
    /* Styles g√©n√©raux du corps de la page */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px;
      background-color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    /* Styles des titres et textes d'information */
    h1 {
      color: #333;
      font-size: 1.8em;
      margin-bottom: 10px;
    }
    p#instruction {
      font-size: 1.1em;
      margin-bottom: 10px;
      color: #555;
      min-height: 1.5em; /* Emp√™che le texte de sauter si son contenu change */
    }
    p#levelDisplay {
        font-size: 1.1em;
        font-weight: bold;
        color: #007bff;
        margin-top: 5px;
        margin-bottom: 15px;
    }
    #timerDisplay {
        font-size: 1.3em;
        font-weight: bold;
        color: #d9534f; /* Rouge par d√©faut */
        margin-bottom: 20px;
        min-height: 1.5em; /* Emp√™che le texte de sauter */
    }

    /* Styles de la grille de jeu */
    .grid {
      display: grid;
      grid-template-columns: repeat(4, 65px); /* Taille des cellules pour mobile */
      grid-gap: 8px; /* Espacement entre les cellules */
      justify-content: center;
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 10px;
      background-color: #fff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      width: fit-content; /* La grille s'adapte √† la taille de son contenu */
      max-width: 100%; /* Emp√™che le d√©bordement sur les petits √©crans */
    }

    /* Styles des cellules individuelles */
    .cell {
      width: 65px;
      height: 65px;
      background-color: #ccc;
      border-radius: 10px;
      cursor: pointer;
      position: relative;
      transition: background-color 0.15s ease-in-out; /* Transition rapide pour le clignotement */
      user-select: none; /* Emp√™che la s√©lection du texte */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .cell span {
      font-size: 20px;
      font-weight: bold;
      color: white;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none; /* Emp√™che le span d'intercepter les clics */
    }

    /* Couleurs des √©tats des cellules */
    .cell.active {
      background-color: #1E90FF; /* Bleu vif quand la case s'allume */
    }
    .cell.correct {
      background-color: #28a745; /* Vert quand la case est correctement cliqu√©e */
    }
    .cell.wrong {
      background-color: #dc3545; /* Rouge quand la case est mal cliqu√©e */
    }

    /* Animation pour les r√©p√©titions de cases */
    .cell.flash-repeat {
        animation: flashRepeat 0.6s infinite alternate; /* Clignotement rapide et continu */
    }
    @keyframes flashRepeat {
        from { background-color: #1E90FF; } /* Commence bleu vif */
        to { background-color: #87CEFA; } /* Termine bleu plus clair */
    }

    /* Styles des boutons */
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 8px 5px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      transition: background-color 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      flex-shrink: 0; /* Emp√™che les boutons de r√©tr√©cir sur mobile */
    }
    button:hover:not(:disabled) {
      background-color: #0056b3;
    }
    button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    /* Media Queries pour les √©crans plus grands (tablettes et ordinateurs) */
    @media (min-width: 768px) {
        h1 {
            font-size: 2.5em;
        }
        p#instruction, p#levelDisplay, #timerDisplay {
            font-size: 1.2em;
        }
        .grid {
            grid-template-columns: repeat(4, 80px); /* Retour √† la taille originale des cellules */
            grid-gap: 10px;
            padding: 20px;
        }
        .cell {
            width: 80px;
            height: 80px;
        }
        .cell span {
            font-size: 24px;
        }
        button {
            padding: 12px 25px;
            font-size: 18px;
            margin: 10px 8px;
        }
    }
  </style>
</head>
<body>
  <h1>Trouve la bonne case !</h1>
  <p id="instruction">Clique sur "Commencer" pour d√©marrer</p>
  <p id="levelDisplay">Niveau : 0</p>
  <p id="timerDisplay">Temps : --</p>
  <div class="grid" id="grid"></div>
  
  <div class="button-container">
    <button id="startButton" onclick="startGame()">Commencer</button>
    <button id="resetButton" onclick="resetGame()">Rejouer</button>
  </div>

  <script>
    const gridSize = 4; // Taille de la grille (4x4)
    let sequence = []; // S√©quence des cases √† m√©moriser
    let playerIndex = 0; // Index de la case actuelle que le joueur doit cliquer dans la s√©quence
    let isPlayingSequence = false; // Vrai si la s√©quence est en cours de lecture, faux si c'est au tour du joueur
    let currentLevel = 0; // Niveau actuel du joueur

    // Variables pour le minuteur
    let timerValue = 10; // Valeur initiale du minuteur en secondes
    let timerInterval; // Pour stocker l'ID de l'intervalle du minuteur (permet de l'arr√™ter)
    const maxTimerValue = 20; // Valeur maximale que le minuteur peut atteindre

    // R√©f√©rences aux √©l√©ments du DOM
    const grid = document.getElementById("grid");
    const instruction = document.getElementById("instruction");
    const levelDisplay = document.getElementById("levelDisplay");
    const timerDisplay = document.getElementById("timerDisplay");
    const startButton = document.getElementById("startButton");
    const resetButton = document.getElementById("resetButton");

    // Mapping des noms de niveaux fun et provocateurs
    const levelNames = {
        0: "Pr√™t √† relever le d√©fi ?", // Niveau initial avant le jeu
        1: "M√©moire de Moustique",
        2: "Ciboulot en Rodage",
        3: "Ciboulot en Rodage",
        4: "Neurone en √âveil",
        5: "Neurone en √âveil",
        6: "Cerveau Agile",
        7: "Cerveau Agile",
        8: "Ma√Ætre des Cases",
        9: "Ma√Ætre des Cases",
        10: "G√©nie Incompris",
        11: "G√©nie Incompris",
        12: "G√©nie Incompris",
        13: "G√©nie Incompris",
        14: "G√©nie Incompris",
        15: "L√©gende Vivante",
        16: "L√©gende Vivante",
        17: "L√©gende Vivante",
        18: "L√©gende Vivante",
        19: "L√©gende Vivante",
        20: "Dieu de la M√©moire" // Pour le niveau 20 et au-del√†
    };

    // Messages provocateurs en cas de d√©faite
    const losingMessages = {
        1: "S√©rieusement ? Un moustique fait mieux !",
        2: "Ton cerveau vient de d√©marrer ou quoi ?",
        3: "On dirait que tu es toujours en rodage...",
        4: "Tes neurones sont encore au lit ?",
        5: "Pas de panique, le cerveau, √ßa s'entra√Æne... ou pas.",
        6: "Tu as presque touch√© la gloire. Presque.",
        7: "Dommage ! On y croyait, nous...",
        8: "Le Ma√Ætre des Cases est tomb√©... Reviens plus fort, si tu peux !",
        9: "Tu as laiss√© √©chapper ta victoire. Quel dommage !",
        10: "M√™me les g√©nies incompris ont leurs faiblesses. La tienne, c'est la m√©moire ?",
        15: "Une L√©gende Vivante ne devrait pas tomber si facilement... Ou alors, tu n'√©tais pas si l√©gendaire ?",
        20: "M√™me un Dieu de la M√©moire peut avoir un coup de mou... ou est-ce juste une excuse ?"
    };

    /**
     * Retourne le message de d√©faite correspondant au niveau donn√©.
     */
    function getLosingMessage(level) {
        if (level >= 20) return losingMessages[20];
        if (level >= 15) return losingMessages[15];
        if (level >= 10) return losingMessages[10];
        if (level >= 8) return losingMessages[8];
        if (level >= 6) return losingMessages[6];
        if (level >= 4) return losingMessages[4];
        if (level >= 2) return losingMessages[2];
        return losingMessages[1] || "Pas de chance ! Tente encore !"; // Message par d√©faut
    }

    /**
     * Retourne le nom du niveau correspondant au num√©ro donn√©.
     * G√®re les niveaux au-del√† de 20 en retournant le nom du "Dieu de la M√©moire".
     */
    function getLevelName(level) {
        if (level >= 20) {
            return levelNames[20];
        }
        return levelNames[level] || "Niveau Inconnu"; // Fallback au cas o√π un niveau n'est pas mapp√©
    }

    /**
     * Met √† jour l'affichage du niveau avec son num√©ro et son nom.
     */
    function updateLevelDisplay() {
        const name = getLevelName(currentLevel);
        levelDisplay.textContent = `Niveau ${currentLevel} : ${name}`;
    }

    /**
     * Met √† jour l'affichage du minuteur et sa couleur en fonction du temps restant.
     */
    function updateTimerDisplay() {
        timerDisplay.textContent = `Temps : ${timerValue}`;
        if (timerValue <= 5 && timerValue > 0) {
            timerDisplay.style.color = '#d9534f'; // Rouge si peu de temps
        } else if (timerValue > 5) {
            timerDisplay.style.color = '#28a745'; // Vert si assez de temps
        }
    }

    /**
     * D√©marre le minuteur qui d√©cr√©mente chaque seconde.
     * Appelle `gameOver` si le temps atteint z√©ro.
     */
    function startTimer() {
        clearInterval(timerInterval); // Emp√™che d'avoir plusieurs minuteurs en m√™me temps
        timerInterval = setInterval(() => {
            if (isPlayingSequence) return; // Ne d√©cr√©mente pas pendant que la s√©quence est jou√©e

            timerValue--;
            updateTimerDisplay();

            if (timerValue <= 0) {
                clearInterval(timerInterval);
                gameOver(false); // Le joueur perd par manque de temps
            }
        }, 1000); // D√©cr√©mente toutes les secondes
    }

    /**
     * Arr√™te le minuteur.
     */
    function stopTimer() {
        clearInterval(timerInterval);
    }

    /**
     * R√©initialise l'√©tat visuel de toutes les cellules de la grille.
     */
    function resetGrid() {
      const cells = document.querySelectorAll(".cell");
      cells.forEach(cell => {
        cell.className = "cell";     // R√©initialise toutes les classes
        cell.innerHTML = "";         // Supprime les num√©ros/spans
        cell.style.backgroundColor = ""; // Supprime tout style de fond inline
        cell.classList.remove('flash-repeat'); // S'assure que l'animation de r√©p√©tition est supprim√©e
      });
    }

    /**
     * D√©marre une nouvelle partie.
     * R√©initialise toutes les variables de jeu et lance le premier tour.
     */
    function startGame() {
      startButton.disabled = true; // D√©sactive le bouton "Commencer"
      resetButton.disabled = false; // Active le bouton "Rejouer"

      resetGrid();
      sequence = [];
      playerIndex = 0;
      currentLevel = 0; // R√©initialise le niveau √† 0
      timerValue = 10; // R√©initialise le minuteur
      updateLevelDisplay();
      updateTimerDisplay();
      nextRound(); // Lance le premier tour
    }

    /**
     * R√©initialise compl√®tement le jeu √† son √©tat initial.
     */
    function resetGame() {
      resetGrid();
      sequence = [];
      playerIndex = 0;
      isPlayingSequence = false;
      currentLevel = 0; // R√©initialise le niveau
      timerValue = 10; // R√©initialise le minuteur
      updateLevelDisplay();
      updateTimerDisplay();
      instruction.textContent = "Clique sur 'Commencer' pour d√©marrer";
      stopTimer(); // Arr√™te le minuteur si le jeu est r√©initialis√©

      startButton.disabled = false; // R√©active le bouton "Commencer"
      resetButton.disabled = true; // D√©sactive le bouton "Rejouer"
    }

    /**
     * Pr√©pare et lance le tour suivant.
     * Ajoute une nouvelle case √† la s√©quence et lance son affichage.
     */
    function nextRound() {
      resetGrid();
      instruction.textContent = "üß† Regarde bien...";
      stopTimer(); // Arr√™te le minuteur pendant que la s√©quence est montr√©e
      
      const newIndex = Math.floor(Math.random() * (gridSize * gridSize));
      sequence.push(newIndex); // Ajoute une nouvelle case √† la s√©quence
      isPlayingSequence = true; // Emp√™che les clics du joueur
      playerIndex = 0; // R√©initialise l'index du joueur pour la nouvelle s√©quence
      currentLevel++; 
      updateLevelDisplay(); // Met √† jour l'affichage du niveau
      playSequence(sequence); // Lance l'affichage de la s√©quence
    }

    /**
     * Affiche visuellement la s√©quence de cases que le joueur doit m√©moriser.
     * G√®re le clignotement des cases et l'indication des r√©p√©titions.
     */
    function playSequence(seq) {
      let i = 0;
      const cells = document.querySelectorAll(".cell");

      const sequenceInterval = setInterval(() => {
        // √âteindre la cellule pr√©c√©dente (si elle n'est pas la m√™me que la courante)
        if (i > 0) {
            const prevCell = cells[seq[i - 1]];
            prevCell.classList.remove("active");
            prevCell.classList.remove("flash-repeat"); // S'assurer que l'animation s'arr√™te
        }
        
        // Si toutes les cases de la s√©quence ont √©t√© affich√©es
        if (i === seq.length) {
          clearInterval(sequenceInterval);
          // D√©lai avant de passer au tour du joueur pour une meilleure transition
          setTimeout(() => {
            isPlayingSequence = false; // Autorise les clics du joueur
            instruction.textContent = "üëâ √Ä toi de jouer !";
            startTimer(); // D√©marre le minuteur pour le tour du joueur
          }, 500);
          return;
        }

        const currentCell = cells[seq[i]];
        currentCell.classList.add("active"); // Allume la cellule actuelle

        // D√©tecter si la m√™me case se r√©p√®te cons√©cutivement (pour l'animation de r√©p√©tition)
        if (i > 0 && seq[i] === seq[i-1]) {
            currentCell.classList.add('flash-repeat'); // Ajoute une animation de clignotement
        } else {
            currentCell.classList.remove('flash-repeat'); // Retire l'animation si pas de r√©p√©tition
        }

        // √âteindre la cellule apr√®s un court d√©lai pour cr√©er l'effet de clignotement
        setTimeout(() => {
            currentCell.classList.remove("active");
            // Si c'est une r√©p√©tition, l'animation de clignotement reste active
            if (i > 0 && seq[i] === seq[i-1]) {
                 currentCell.classList.add('flash-repeat');
            } else {
                 currentCell.classList.remove('flash-repeat');
            }
        }, 400); // La case reste allum√©e 400ms

        i++;
      }, 800); // Temps entre le d√©but de l'allumage de chaque cellule dans la s√©quence
    }

    /**
     * G√®re le clic du joueur sur une cellule.
     * V√©rifie si la case est la bonne, met √† jour le minuteur et le progr√®s du joueur.
     */
    function handleClick(e) {
      // Ignore les clics si la s√©quence est jou√©e ou si le jeu n'a pas encore commenc√©
      if (isPlayingSequence || startButton.disabled === false) return;

      const index = parseInt(e.target.dataset.index); // Index de la case cliqu√©e
      const expected = sequence[playerIndex]; // Index de la case attendue
      const cells = document.querySelectorAll(".cell");

      if (index === expected) {
        // Bonne case cliqu√©e
        e.target.classList.add("correct"); // Colore la case en vert
        timerValue = Math.min(timerValue + 2, maxTimerValue); // Augmente le minuteur de 2 secondes, max 20
        updateTimerDisplay();

        setTimeout(() => e.target.classList.remove("correct"), 300); // Retire la couleur apr√®s un court instant
        playerIndex++; // Passe √† la prochaine case attendue dans la s√©quence

        if (playerIndex === sequence.length) {
          // S√©quence compl√®te r√©ussie, passer au tour suivant
          instruction.textContent = "‚úÖ Bien jou√© ! Nouvelle s√©quence...";
          stopTimer(); // Arr√™te le minuteur entre les tours
          setTimeout(nextRound, 800); 
        }
      } else {
        // Mauvaise case cliqu√©e
        stopTimer(); // Arr√™te le minuteur
        gameOver(true); // Le joueur a perdu √† cause d'une mauvaise case
      }
    }

    /**
     * G√®re la fin de partie, que ce soit par erreur de clic ou par temps √©coul√©.
     * Affiche la s√©quence correcte et r√©initialise le jeu.
     * @param {boolean} isWrongClick - Vrai si la partie est termin√©e par un mauvais clic, Faux si par le temps.
     */
    function gameOver(isWrongClick) {
        isPlayingSequence = true; // Emp√™che les clics suppl√©mentaires pendant l'animation de fin
        startButton.disabled = true; // D√©sactive les boutons pendant l'animation
        resetButton.disabled = true;

        const finalLevel = currentLevel - 1; // Le niveau atteint est le dernier niveau r√©ussi
        const levelName = getLevelName(finalLevel);
        const losingMsg = getLosingMessage(finalLevel);

        if (isWrongClick) {
            instruction.textContent = `‚ùå Perdu ! La s√©quence √©tait :`;
            alert(`Dommage ! Vous avez atteint le niveau ${finalLevel} : ${levelName}.\n\n${losingMsg}`);
        } else {
            instruction.textContent = `‚è∞ Temps √©coul√© ! La s√©quence √©tait :`;
            alert(`Temps √©coul√© ! Vous avez atteint le niveau ${finalLevel} : ${levelName}.\n\n${losingMsg}`);
        }
        
        // Nettoie l'√©tat visuel de toutes les cellules avant de montrer la solution
        const cells = document.querySelectorAll(".cell");
        cells.forEach(c => {
            c.classList.remove("active", "correct", "wrong", "flash-repeat");
            c.innerHTML = "";
            c.style.backgroundColor = "";
        });

        // Animation de la s√©quence compl√®te (1 √† N) pour montrer la solution
        let animationIndex = 0;
        const solutionAnimationInterval = setInterval(() => {
            if (animationIndex >= sequence.length) {
                clearInterval(solutionAnimationInterval);
                // Apr√®s l'animation, attendre un peu puis r√©initialiser le jeu
                setTimeout(() => {
                    resetGame(); // R√©initialise le jeu et r√©active les boutons
                    startButton.disabled = false;
                    resetButton.disabled = false;
                }, 1000); // Laisse un peu de temps apr√®s l'animation finale
                return;
            }

            const cellToShow = cells[sequence[animationIndex]];
            cellToShow.innerHTML = `<span>${animationIndex + 1}</span>`; // Affiche le num√©ro d'ordre (1, 2, 3...)
            cellToShow.style.backgroundColor = "#1E90FF"; // Colore la cellule en bleu pour la solution

            // Fait clignoter la case en l'√©teignant apr√®s un court d√©lai
            setTimeout(() => {
                cellToShow.style.backgroundColor = "";
            }, 500); // Chaque chiffre reste affich√© 0.5s

            animationIndex++;
        }, 700); // D√©lai entre l'affichage de chaque chiffre de la solution
    }

    // Cr√©ation des cellules de la grille au chargement de la page
    for (let i = 0; i < gridSize * gridSize; i++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      cell.dataset.index = i;
      cell.addEventListener("click", handleClick);
      grid.appendChild(cell);
    }

    // Initialisation des √©l√©ments du jeu au chargement de la page
    resetButton.disabled = true;
    updateLevelDisplay();
    updateTimerDisplay(); // Affiche le minuteur initial
  </script>
</body>
</html>
